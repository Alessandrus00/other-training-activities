""" This file is used to generate the region and place the pick-up/delivery cites at random """

import numpy as np
import random
from scipy.spatial import distance_matrix
from utils import load_parameters
from utils import plot_region, none_or_int
import argparse
import pickle as pk
import os.path as osp


def get_args_parser():
    parser = argparse.ArgumentParser('Set parameters', add_help=False)
    parser.add_argument('--parameters', default='parameters.yaml', type=str, help="Path to the parameters file")
    parser.add_argument('--seed', default=None, type=none_or_int, help="Seed used for random placements of pick-up/delivery sites")
    parser.add_argument('--output_dir', default='./instances', type=str, help="Where to save the region data file generated by this code")

    return parser


def create_grid(width_km, height_km, cell_size_km):
    """Create a grid with the specified dimensions and cell size."""
    x_coords = np.arange(0, width_km, cell_size_km)
    y_coords = np.arange(0, height_km, cell_size_km)
    grid = [(x, y) for x in x_coords for y in y_coords]
    return grid

def calculate_distance(loc1, loc2):
    """Calculate Euclidean distance between two locations."""
    return np.sqrt((loc1[0] - loc2[0])**2 + (loc1[1] - loc2[1])**2)

def cities_too_close(city1, city2, min_distance_km):
    """Check if two points (city centers) are too close."""
    x1, y1 = city1
    x2, y2 = city2
    return calculate_distance((x1, y1), (x2, y2)) < min_distance_km

def place_city_centers(grid, num_cities, min_distance_km, city_radius_min, city_radius_max, width_km, height_km):
    """Place city centers on the grid ensuring a minimum distance between them."""
    city_centers = []
    city_radii = []
    while len(city_centers) < num_cities:
        candidate = random.choice(grid)
        
        if all(not cities_too_close(candidate, center, min_distance_km) for center in city_centers):
            city_centers.append(candidate)
            city_radii.append(random.uniform(city_radius_min, city_radius_max))
                
    return city_centers, city_radii

def place_sites_around_city_centers(grid, city_centers, city_radii, num_sites, city_radius_max, prob_inside, prob_outside):
    """Place pick-up/delivery sites around city centers with specified probabilities."""
    sites = []
    
    while len(sites) < num_sites:
        candidate = random.choice(grid)
        
        if any(calculate_distance(candidate, center) <= radius for center, radius in zip(city_centers, city_radii)):
            if random.random() < prob_inside:
                sites.append(candidate)
        else:
            if random.random() < prob_outside:
                sites.append(candidate)
                
    return sites

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Set parameters", parents=[get_args_parser()])
    args = parser.parse_args()
    
    # Load the parameters
    params = load_parameters(args.parameters)
    region_param = params['region']
    
    random.seed(args.seed)
    
    # Generate grid and place city centers
    grid = create_grid(region_param['width_km'], region_param['height_km'], region_param['cell_size_km'])
    city_centers, city_radii = place_city_centers(grid, region_param['num_cities'], region_param['min_distance_km'], region_param['city_radius_min'], region_param['city_radius_max'], region_param['width_km'], region_param['height_km'])

    # Place pick-up/delivery sites around city centers
    sites = place_sites_around_city_centers(grid, city_centers, city_radii, region_param['num_sites'], region_param['city_radius_max'], region_param['prob_inside'], region_param['prob_outside'])

    # Save region data
    region = {}
    region['grid'] = grid
    region['city_centers'] = city_centers
    region['city_radii'] = city_radii
    region['sites'] = sites
    
    # Save the object to a file using pickle
    filepath = osp.join(args.output_dir, "region_data.pkl")
    with open(filepath, 'wb') as file:
        pk.dump(region, file)
        
    # Save the plot
    filepath_plot = osp.join(args.output_dir, "region.png") 
    plot_region(grid, sites, region_param['num_sites'], region_param['width_km'], region_param['height_km'], filepath_plot) # optional to visualize the region and its sites
    
    print("Region data saved to:", filepath)
    print("Region plot saved to:", filepath_plot)
    


